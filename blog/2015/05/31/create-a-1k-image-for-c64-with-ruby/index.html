<!DOCTYPE html> <html> <head> <meta charset=utf-8> <meta content='IE=edge,chrome=1' http-equiv=X-UA-Compatible> <meta content='width=device-width, initial-scale=1' name=viewport> <title>64 Bites - Episode Create a 1k Image for Commodore 64 with Ruby</title> <link href="../../../../../assets/stylesheets/application.css" rel=stylesheet /> <link href="../../../../../assets/images/favicon.ico" rel=icon type="image/ico"/> <link href='favicon-76.png' rel=apple-touch-icon> <link href='favicon-120.png' rel=apple-touch-icon sizes=120x120> <link href='favicon-152.png' rel=apple-touch-icon sizes=152x152> <link href='favicon-180.png' rel=apple-touch-icon sizes=180x180> <meta content='http://64bites.com/assets/images/blog/001/thumbnail.png' property='og:image'> <meta content='http://64bites.com/blog/2015/05/31/create-a-1k-image-for-c64-with-ruby/' property='og:url'> <meta content='64 Bites Blog - Create a 1k Image for Commodore 64 with Ruby' property='og:title'> <meta content='video.episode' property='og:type'> <meta content='&#x000A;&lt;p&gt;At the end of the &lt;a href="/episodes/006-read-data"&gt;Episode #006 - Read Data&lt;/a&gt; you can see a low-resolution image made out of characters. It was made using the READ command to pick values from a large DATA sequence and then POKE them into the screen memory. As the data set is rather large, we would prefer to generate it automatically… &lt;/p&gt;&#x000A;&#x000A;&lt;p&gt;' property='og:description'> <meta content=Yaz0CxBUbKaWP3BWbjlc_JEq0LhifBVnTBzYuXtYQBE name=google-site-verification> <link rel=alternate type="application/atom+xml" title="Atom Feed" href="/blog/feed.xml"/> <script>
    !function(f,b,e,v,n,t,s){if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};if(!f._fbq)f._fbq=n;
    n.push=n;n.loaded=!0;n.version='2.0';n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];s.parentNode.insertBefore(t,s)}(window,
    document,'script','https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '722589087875219');
    fbq('track', 'PageView');
    </script> <noscript><img height=1 width=1 style="display:none" src="https://www.facebook.com/tr?id=722589087875219&ev=PageView&noscript=1"/></noscript> <script src="//load.sumome.com/" data-sumo-site-id=c167ac76bada36448d781af88ae69aa3b95ed02cbfd2d52db8484894bc7bd8da async=async></script> </head> <body class='blog blog_2015 blog_2015_05 blog_2015_05_31 blog_2015_05_31_create-a-1k-image-for-c64-with-ruby blog_2015_05_31_create-a-1k-image-for-c64-with-ruby_index'> <div class=container> <header> <a class=logo href="/"></a> <div class=navigation-bar> <ul> <li><a class="" href="/subscription">Subscription</a></li> <li><a class="" href="/seasons/all">Seasons</a></li> <li><a class="" href="/episodes/all">Episodes</a></li> <li><a class="" href="/blog">Blog</a></li> <li><a class="" href="https://www.facebook.com/groups/64bitesVIP">Forums</a></li> <li><a class="" href="/64spec">Open Source</a></li> </ul> </div> </header> <main> <h1>Create a 1k Image for Commodore 64 with Ruby</h1> <p>At the end of the <a href="/episodes/006-read-data">Episode #006 - Read Data</a> you can see a low-resolution image made out of characters. It was made using the READ command to pick values from a large DATA sequence and then POKE them into the screen memory. As the data set is rather large, we would prefer to generate it automatically… </p> <p></p> <p>The screen of Commodore 64 can display 25 rows of 40 characters. If you fill it with fully opaque characters, it can be used to display a ridiculously low-resolution image (40x25 = 1k of huge pixels in total).</p> <p><img alt="64bites logo made from colored characters" src="../../../../../assets/images/blog/001/screen-shot.png"/></p> <p>For example the image above can be generated by the following program:</p> <pre><code class="basic">
        10 for y = 0 to 24
        20 for x = 0 to 39
        30 o = 40 * y + x
        40 poke 1024 + o, 160
        45 read c
        50 poke 55296 + o, c
        60 next x,y
        70 goto 70
        1000 data 14,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
        1010 data 9,9,9,9,9,9,9,9,14,14,14,9,9,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2
        1020 data 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,9,9,14,9,9,9,2,2,2,2,2,2,2
        1030 data 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,9,9,9
        1040 data 9,9,9,9,9,9,9,9,9,9,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,1,1,1,1,9
        1050 data 9,9,9,9,9,9,9,9,9,9,9,9,9,8,8,8,8,8,8,1,1,1,1,1,1,1,1,1,8,8
        1060 data 8,8,8,8,1,1,12,1,1,12,8,8,8,8,8,8,8,9,9,9,9,9,9,8,8,8,8,8,1,1
        1070 data 12,12,12,12,12,12,1,1,12,8,8,8,8,1,1,12,8,1,1,12,8,8,8,8,8,8,8,9,9,9
        1080 data 9,9,9,9,9,9,9,9,1,1,11,9,9,9,9,9,9,11,11,9,9,9,1,1,11,9,9,1,1,11
        1090 data 9,9,9,9,9,9,9,9,9,9,9,9,9,7,7,7,7,7,1,1,15,1,1,1,1,1,1,7,7,7
        1100 data 7,1,1,15,7,7,7,1,1,15,7,7,7,7,7,7,7,9,9,9,9,9,9,7,7,7,7,7,1,1
        1110 data 1,1,1,1,1,1,1,1,7,7,1,1,15,7,7,7,7,1,1,15,7,7,7,7,7,7,7,9,9,9
        1120 data 9,9,9,9,9,9,9,9,1,1,11,11,11,11,11,11,1,1,11,9,1,1,1,1,1,1,1,1,1,1
        1130 data 1,9,9,9,9,9,9,9,9,9,9,9,9,5,5,5,5,5,1,1,12,5,5,5,5,5,1,1,12,5
        1140 data 1,1,1,1,1,1,1,1,1,1,1,12,5,5,5,5,5,9,9,9,9,9,9,5,5,5,5,5,1,1
        1150 data 1,1,1,1,1,1,1,1,12,5,5,12,12,12,12,12,12,1,1,12,12,12,5,5,5,5,5,9,9,9
        1160 data 9,9,9,9,9,9,9,9,9,1,1,1,1,1,1,1,1,11,11,9,9,9,9,9,9,9,9,1,1,11
        1170 data 9,9,9,9,9,9,9,9,9,9,9,9,9,6,6,6,6,6,6,6,12,12,12,12,12,12,12,12,6,6
        1180 data 6,6,6,6,6,6,6,6,12,12,6,6,6,6,6,6,6,9,9,9,9,9,9,6,6,6,6,6,6,6
        1190 data 6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,9,9,9
        1200 data 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
        1210 data 9,9,9,9,9,9,9,9,9,9,9,9,9,9,1,9,9,9,9,9,9,9,1,1,9,9,9,9,9,9
        1220 data 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,1,9,9,9,9,9
        1230 data 9,9,9,9,9,9,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
        1240 data 9,9,9,9,1,9,1,1,1,9,9,9,1,9,9,1,1,1,1,1,9,9,9,1,1,1,1,9,9,9
        1250 data 1,1,1,1,1,9,9,9,9,9,9,9,9,9,1,1,9,9,1,1,9,9,1,1,9,9,1,9,9,9
        1260 data 9,9,1,9,9,9,1,1,9,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,1,9,9,9,9,1
        1270 data 9,9,1,1,9,9,1,9,9,9,9,1,1,1,1,1,1,1,9,1,1,1,1,1,1,1,9,9,9,9
        1280 data 9,9,9,9,1,1,9,9,1,1,9,9,1,1,9,9,1,9,9,1,9,9,1,9,9,9,9,9,9,9
        1290 data 9,9,9,9,1,1,9,9,9,9,9,9,9,9,1,9,1,1,1,9,9,9,1,1,9,9,1,1,1,1
        1300 data 9,9,9,1,1,1,1,9,9,9,1,1,1,1,1,9,9,9,9,9,14,9,9,9,9,9,9,9,9,9
        1310 data 9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,14
        1320 data 14,14,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9
        1330 data 9,9,9,9,9,9,9,9,14,14 
        </code></pre> <h2 id=that-sounds-like-a-lot-of-typing>That sounds like a lot of typing…</h2> <p>While we could create all those DATA statements by hand, there is a better way. If we have a small 40x25 image, we could use it to generate the required DATA statements. To do that we need to match the color of every pixel of the image with a corresponding index of that color in the C64 palette. To simplify this process, we'll use the 16x1 palette image filled with C64 colors in the correct order. Now if we go through each of the pixels in the first image and find the corresponding color in the palette image, the index of that color will be the correct C64 color number. </p> <p><img alt=Algorithm src="../../../../../assets/images/blog/001/algorithm.png"/></p> <h2 id=lets-see-that-in-code>Let's see that in code</h2> <p>We will use a simple Ruby script to do that. First we'll require the <code>chunky_png</code> gem to be able to work with png files.</p> <pre><code class="ruby">
        require 'chunky_png'
        </code></pre> <p>Now we will read colors out of the <code>palette.png</code> file and store it's index in the <code>colors</code> hash. </p> <pre><code class="ruby">
        colors = {}
        palette = ChunkyPNG::Image.from_file('palette.png')
        (0...palette.dimension.width).each do |index|
          colors[palette[index, 0]] = index
        end
        </code></pre> <p>Then we'll iterate through each pixel of the <code>image40x25.png</code> file, row by row. Match the pixel's color to it's index. And store the index in a <code>color_indices</code> array.</p> <pre><code class="ruby">
        color_indices = []
        image = ChunkyPNG::Image.from_file('image40x25.png')
        (0...image.dimension.height).each do |y|
          (0...image.dimension.width).each do |x|
            color_indices &lt;&lt; colors[image[x, y]]
          end
        end
        </code></pre> <p>Finally, we can use <code>color_indices</code> to create <code>DATA</code> statements. We'll print thirty indices per one <code>DATA</code> line to make sure we don't exceed the maximum limit of eighty characters. </p> <pre><code class="ruby">
        color_indices.each_slice(30).with_index do |row, index|
          puts "#{1000 + 10 * index} data #{row.join(",")}"
        end
        </code></pre> <h2 id=make-your-own-images>Make your own images!</h2> <p>This <a href="../../../../articles/001-create-a-1k-image-for-c64-with-ruby/data-statement-generator.zip">zip file</a> contains the required images palette.png, image25x40.png and the ruby script - make_data.rb that you can use to create low-resolution images yourself.</p> <p>Have Fun!</p> <section class=buy> <div class=buy-button> <p>You can get the subscription for $10.99/month or $109/year (two months for free).</p> <a class=button href="https://gumroad.com/l/64bites">I want a new episode each week!</a> <p>Get <strong> 13 latest episodes now</strong> and a <strong>new one each week</strong>.<br/>All with <strong>detailed transcripts</strong>, <strong>source code examples</strong> and <strong>programming exercises</strong>.</p> <div> </div></div></section> <hr> </main> <footer> <span> Copyright © 2014-2017 Creative Mind - Michal Taszycki </span> </footer> </div> <script src="https://code.jquery.com/jquery-2.1.1.min.js"></script><script src="../../../../../assets/javascripts/application.js"></script> <script>
      !function(){var analytics=window.analytics=window.analytics||[];if(!analytics.initialize)if(analytics.invoked)window.console&&console.error&&console.error("Segment snippet included twice.");else{analytics.invoked=!0;analytics.methods=["trackSubmit","trackClick","trackLink","trackForm","pageview","identify","reset","group","track","ready","alias","page","once","off","on"];analytics.factory=function(t){return function(){var e=Array.prototype.slice.call(arguments);e.unshift(t);analytics.push(e);return analytics}};for(var t=0;t<analytics.methods.length;t++){var e=analytics.methods[t];analytics[e]=analytics.factory(e)}analytics.load=function(t){var e=document.createElement("script");e.type="text/javascript";e.async=!0;e.src=("https:"===document.location.protocol?"https://":"http://")+"cdn.segment.com/analytics.js/v1/"+t+"/analytics.min.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)};analytics.SNIPPET_VERSION="3.1.0";
      analytics.load("3z8xJ01MQLwMsgpwWuPmw2BTxor55hoB");
      analytics.page()
      }}();
    </script> <script src="//platform.twitter.com/oct.js"></script> <script>twttr.conversion.trackPid('nthnq', { tw_sale_amount: '0', tw_order_quantity: '0' });</script> <noscript> <img height=1 width=1 style="display:none;" alt="" src="https://analytics.twitter.com/i/adsct?txn_id=nthnq&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"/> <img height=1 width=1 style="display:none;" alt="" src="//t.co/i/adsct?txn_id=nthnq&p_id=Twitter&tw_sale_amount=0&tw_order_quantity=0"/> </noscript> <script src="https://gumroad.com/js/gumroad.js"></script> <script>
      var _dcq = _dcq || [];
      var _dcs = _dcs || {}; 
      _dcs.account = '8833932';
      
      (function() {
        var dc = document.createElement('script');
        dc.type = 'text/javascript'; dc.async = true; 
        dc.src = '//tag.getdrip.com/8833932.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(dc, s);
      })();
    </script> </body> </html>